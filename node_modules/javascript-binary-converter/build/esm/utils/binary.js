import { getTwosComplementBinary, splitBinaryStringToBytes } from "./bits";
import { getSystemEndianness } from "./crossPlatform";
import { getClosestDividable, isBigInt, isFloat, normalizeBigInt } from "./number";
import { padString } from "./string";
export function integerToBinary(decimal) {
    const binary = (decimal >>> 0).toString(2);
    return binary;
}
export function floatToBinary(float, { precision = 'SINGLE' } = {}) {
    const floatTypedArray = precision === 'SINGLE' ? new Float32Array([float]) : new Float64Array([float]);
    const int8 = new Uint8Array(floatTypedArray.buffer);
    const bytes = typedArrayToBytes(int8);
    const endianness = getSystemEndianness();
    return endianness === 'LITTLE' ? bytes.reverse().join("") : bytes.join("");
}
export function binaryToFloat(binary, { precision = 'SINGLE' } = {}) {
    const numBits = precision === 'SINGLE' ? 32 : 64;
    const numBytes = numBits / 8;
    binary = padString(binary, numBits);
    const bytes = splitBinaryStringToBytes(binary);
    var buffer = new ArrayBuffer(numBytes);
    var uint8 = new Uint8Array(buffer);
    for (let i = 0; i < bytes.length; i++) {
        uint8[i] = binaryToInteger(bytes[i]);
    }
    var view = new DataView(buffer);
    return precision === 'SINGLE' ? view.getFloat32(0, false) : view.getFloat64(0, false);
}
export function bigIntegerToBinary(decimal, nBits = BigInt(64)) {
    const normalizedBigInt = normalizeBigInt(decimal, nBits);
    return normalizedBigInt.toString(2);
}
export function getBytesFromBinary(binaryString, { endianness = 'LITTLE' } = {}) {
    if (binaryString.length <= 7)
        return [padString(binaryString)];
    let closestDividableOfEight = getClosestDividable(binaryString.length, 8);
    const binaryStringWithAppendedZeros = padString(binaryString, closestDividableOfEight);
    let bytes = splitBinaryStringToBytes(binaryStringWithAppendedZeros);
    return endianness === 'LITTLE' ? bytes.reverse() : bytes;
}
export function binaryToInteger(binary, isSigned = false) {
    if (binary.length > 32)
        throw new Error('binaryToInteger does not support bigint');
    return isSigned ? getSignedInteger(binary) : parseInt(binary, 2);
}
export function getSignedInteger(bits) {
    const negative = (bits[0] === '1');
    if (negative) {
        return getDecimalFromTwosComplementBinary(bits); //
    }
    else {
        return parseInt(bits, 2);
    }
}
export function getDecimalFromTwosComplementBinary(binary) {
    const twosComplementBinary = getTwosComplementBinary(binary);
    return parseInt(twosComplementBinary, 2) * -1;
}
export function typedArrayToBytes(typedArray) {
    const bytes = [];
    for (let decimal of typedArray) {
        const binary = integerToBinary(decimal);
        bytes.push(padString(binary, 8));
    }
    return bytes;
}
//relies on a string.seems to be relevant only for strings(not sure if must become generic)
export function groupBytes(bytes, groupSize) {
    const normalizedArray = [];
    let currentBitString = "";
    for (let i = 1; i <= bytes.length; i++) {
        currentBitString += bytes[i - 1];
        if (i % groupSize === 0) {
            normalizedArray.push(currentBitString);
            currentBitString = "";
        }
    }
    return normalizedArray;
}
export function getBytesFromInteger(decimal, { endianness = 'BIG' } = {}) {
    if (typeof decimal === 'number' && isFloat(decimal))
        return getBytesFromBinary(floatToBinary(decimal));
    const bytes = getBytesFromBinary(isBigInt(decimal) ? bigIntegerToBinary(decimal) : integerToBinary(decimal), { endianness });
    return bytes;
}
export function getDecimalBytesFromInteger(decimal, { endianness = 'BIG', isSigned = false } = {}) {
    const bytes = getBytesFromInteger(decimal, { endianness });
    return bytes.map(byte => binaryToInteger(byte, isSigned));
}
export function arrayBufferToBytes(arrayBuffer) {
    const uint8 = new Uint8Array(arrayBuffer);
    return typedArrayToBytes(uint8);
}
export function bytesToIntegers(bytes) {
    return bytes.map(byte => binaryToInteger(byte));
}
export function arrayBufferToDecimalBytes(arrayBuffer, { isSigned = false } = {}) {
    const typedArray = isSigned ? new Int8Array(arrayBuffer) : new Uint8Array(arrayBuffer);
    return Array.from(typedArray);
}
//# sourceMappingURL=binary.js.map