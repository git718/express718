"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitHexStringToHexBytes = exports.hexStringToFloat = exports.hexStringToInteger = exports.binaryToHexString = exports.hexStringToBinary = exports.floatToHexString = exports.bigIntegerToHexaDecimal = exports.integerToHexaDecimal = void 0;
const binary_1 = require("./binary");
const number_1 = require("./number");
const string_1 = require("./string");
function integerToHexaDecimal(integer) {
    return ((integer) >>> 0).toString(16).toUpperCase();
}
exports.integerToHexaDecimal = integerToHexaDecimal;
function bigIntegerToHexaDecimal(integer) {
    const normalizedBigInt = (0, number_1.normalizeBigInt)(integer);
    return normalizedBigInt.toString(16).toUpperCase();
}
exports.bigIntegerToHexaDecimal = bigIntegerToHexaDecimal;
function floatToHexString(float, { precision = 'SINGLE' } = {}) {
    const getHex = (i) => ('00' + i.toString(16)).slice(-2);
    const numberOfBytes = precision === 'SINGLE' ? 4 : 8;
    const view = new DataView(new ArrayBuffer(numberOfBytes));
    if (precision === 'SINGLE') {
        view.setFloat32(0, float);
    }
    else {
        view.setFloat64(0, float);
    }
    const hex = Array
        //@ts-ignore
        .apply(null, { length: numberOfBytes })
        .map((_, i) => getHex(view.getUint8(i)))
        .join('');
    // return hex.toLocaleUpperCase();
    return hex.toLocaleUpperCase();
}
exports.floatToHexString = floatToHexString;
function hexStringToBinary(hex) {
    return parseInt(hex, 16).toString(2).toUpperCase();
}
exports.hexStringToBinary = hexStringToBinary;
function binaryToHexString(binary, { isSigned = false } = {}) {
    var hex = parseInt(binary, 2).toString(16).toUpperCase();
    return hex;
}
exports.binaryToHexString = binaryToHexString;
function hexStringToInteger(hex, { isSigned = false } = {}) {
    if (!isSigned) {
        return parseInt(hex, 16);
    }
    else {
        const binaryFromHex = hexStringToBinary(hex);
        const twosComplementDecimal = (0, binary_1.getDecimalFromTwosComplementBinary)(binaryFromHex);
        return twosComplementDecimal;
    }
}
exports.hexStringToInteger = hexStringToInteger;
function normalizeHex(hex, requireHexLength) {
    if (hex[1] === 'x' || hex[1] === 'X') {
        hex = hex.slice(2);
    }
    return (0, string_1.padString)(hex, requireHexLength, '0');
}
function hexStringToFloat(hex, { precision = 'SINGLE' } = {}) {
    const numBits = precision === 'SINGLE' ? 32 : 64;
    const numBytes = numBits / 8;
    hex = normalizeHex(hex, numBytes * 2);
    const bytes = splitHexStringToHexBytes(hex);
    var buffer = new ArrayBuffer(numBytes);
    var uint8 = new Uint8Array(buffer);
    for (let i = 0; i < bytes.length; i++) {
        uint8[i] = parseInt(bytes[i], 16);
    }
    var view = new DataView(buffer);
    return precision === 'SINGLE' ? view.getFloat32(0, false) : view.getFloat64(0, false);
}
exports.hexStringToFloat = hexStringToFloat;
function splitHexStringToHexBytes(binaryString) {
    return (0, string_1.splitStringToChunks)(binaryString, 2);
}
exports.splitHexStringToHexBytes = splitHexStringToHexBytes;
//# sourceMappingURL=hex.js.map