"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.arrayBufferToDecimalBytes = exports.bytesToIntegers = exports.arrayBufferToBytes = exports.getDecimalBytesFromInteger = exports.getBytesFromInteger = exports.groupBytes = exports.typedArrayToBytes = exports.getDecimalFromTwosComplementBinary = exports.getSignedInteger = exports.binaryToInteger = exports.getBytesFromBinary = exports.bigIntegerToBinary = exports.binaryToFloat = exports.floatToBinary = exports.integerToBinary = void 0;
const bits_1 = require("./bits");
const crossPlatform_1 = require("./crossPlatform");
const number_1 = require("./number");
const string_1 = require("./string");
function integerToBinary(decimal) {
    const binary = (decimal >>> 0).toString(2);
    return binary;
}
exports.integerToBinary = integerToBinary;
function floatToBinary(float, { precision = 'SINGLE' } = {}) {
    const floatTypedArray = precision === 'SINGLE' ? new Float32Array([float]) : new Float64Array([float]);
    const int8 = new Uint8Array(floatTypedArray.buffer);
    const bytes = typedArrayToBytes(int8);
    const endianness = (0, crossPlatform_1.getSystemEndianness)();
    return endianness === 'LITTLE' ? bytes.reverse().join("") : bytes.join("");
}
exports.floatToBinary = floatToBinary;
function binaryToFloat(binary, { precision = 'SINGLE' } = {}) {
    const numBits = precision === 'SINGLE' ? 32 : 64;
    const numBytes = numBits / 8;
    binary = (0, string_1.padString)(binary, numBits);
    const bytes = (0, bits_1.splitBinaryStringToBytes)(binary);
    var buffer = new ArrayBuffer(numBytes);
    var uint8 = new Uint8Array(buffer);
    for (let i = 0; i < bytes.length; i++) {
        uint8[i] = binaryToInteger(bytes[i]);
    }
    var view = new DataView(buffer);
    return precision === 'SINGLE' ? view.getFloat32(0, false) : view.getFloat64(0, false);
}
exports.binaryToFloat = binaryToFloat;
function bigIntegerToBinary(decimal, nBits = BigInt(64)) {
    const normalizedBigInt = (0, number_1.normalizeBigInt)(decimal, nBits);
    return normalizedBigInt.toString(2);
}
exports.bigIntegerToBinary = bigIntegerToBinary;
function getBytesFromBinary(binaryString, { endianness = 'LITTLE' } = {}) {
    if (binaryString.length <= 7)
        return [(0, string_1.padString)(binaryString)];
    let closestDividableOfEight = (0, number_1.getClosestDividable)(binaryString.length, 8);
    const binaryStringWithAppendedZeros = (0, string_1.padString)(binaryString, closestDividableOfEight);
    let bytes = (0, bits_1.splitBinaryStringToBytes)(binaryStringWithAppendedZeros);
    return endianness === 'LITTLE' ? bytes.reverse() : bytes;
}
exports.getBytesFromBinary = getBytesFromBinary;
function binaryToInteger(binary, isSigned = false) {
    if (binary.length > 32)
        throw new Error('binaryToInteger does not support bigint');
    return isSigned ? getSignedInteger(binary) : parseInt(binary, 2);
}
exports.binaryToInteger = binaryToInteger;
function getSignedInteger(bits) {
    const negative = (bits[0] === '1');
    if (negative) {
        return getDecimalFromTwosComplementBinary(bits); //
    }
    else {
        return parseInt(bits, 2);
    }
}
exports.getSignedInteger = getSignedInteger;
function getDecimalFromTwosComplementBinary(binary) {
    const twosComplementBinary = (0, bits_1.getTwosComplementBinary)(binary);
    return parseInt(twosComplementBinary, 2) * -1;
}
exports.getDecimalFromTwosComplementBinary = getDecimalFromTwosComplementBinary;
function typedArrayToBytes(typedArray) {
    const bytes = [];
    for (let decimal of typedArray) {
        const binary = integerToBinary(decimal);
        bytes.push((0, string_1.padString)(binary, 8));
    }
    return bytes;
}
exports.typedArrayToBytes = typedArrayToBytes;
//relies on a string.seems to be relevant only for strings(not sure if must become generic)
function groupBytes(bytes, groupSize) {
    const normalizedArray = [];
    let currentBitString = "";
    for (let i = 1; i <= bytes.length; i++) {
        currentBitString += bytes[i - 1];
        if (i % groupSize === 0) {
            normalizedArray.push(currentBitString);
            currentBitString = "";
        }
    }
    return normalizedArray;
}
exports.groupBytes = groupBytes;
function getBytesFromInteger(decimal, { endianness = 'BIG' } = {}) {
    if (typeof decimal === 'number' && (0, number_1.isFloat)(decimal))
        return getBytesFromBinary(floatToBinary(decimal));
    const bytes = getBytesFromBinary((0, number_1.isBigInt)(decimal) ? bigIntegerToBinary(decimal) : integerToBinary(decimal), { endianness });
    return bytes;
}
exports.getBytesFromInteger = getBytesFromInteger;
function getDecimalBytesFromInteger(decimal, { endianness = 'BIG', isSigned = false } = {}) {
    const bytes = getBytesFromInteger(decimal, { endianness });
    return bytes.map(byte => binaryToInteger(byte, isSigned));
}
exports.getDecimalBytesFromInteger = getDecimalBytesFromInteger;
function arrayBufferToBytes(arrayBuffer) {
    const uint8 = new Uint8Array(arrayBuffer);
    return typedArrayToBytes(uint8);
}
exports.arrayBufferToBytes = arrayBufferToBytes;
function bytesToIntegers(bytes) {
    return bytes.map(byte => binaryToInteger(byte));
}
exports.bytesToIntegers = bytesToIntegers;
function arrayBufferToDecimalBytes(arrayBuffer, { isSigned = false } = {}) {
    const typedArray = isSigned ? new Int8Array(arrayBuffer) : new Uint8Array(arrayBuffer);
    return Array.from(typedArray);
}
exports.arrayBufferToDecimalBytes = arrayBufferToDecimalBytes;
//# sourceMappingURL=binary.js.map