"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const expect_1 = require("expect");
const converter_1 = __importDefault(require("../../converter"));
describe('Node NumberConverter tests', () => {
    it('Should return  hex, from decimal', async function () {
        var bytes = [212, 252, 136, 43434343, -2]; //-44,-4,-120 decimals in twos complement
        var hexes = [];
        hexes[0] = (0, converter_1.default)(bytes[0]).toHexString();
        hexes[1] = (0, converter_1.default)(bytes[1]).toHexString();
        hexes[2] = (0, converter_1.default)(bytes[2]).toHexString();
        hexes[3] = (0, converter_1.default)(bytes[3]).toHexString();
        hexes[4] = (0, converter_1.default)(bytes[4]).toHexString();
        (0, expect_1.expect)(hexes[0]).toBe('D4');
        (0, expect_1.expect)(hexes[1]).toBe('FC');
        (0, expect_1.expect)(hexes[2]).toBe('88');
        (0, expect_1.expect)(hexes[3]).toBe('296C167');
        (0, expect_1.expect)(hexes[4]).toBe('FFFFFFFE');
    });
    it('Should return hex, from bigint', async function () {
        let hex = (0, converter_1.default)(17868022686844715136n).toHexString();
        (0, expect_1.expect)(hex).toBe('F7F7F7F700000080');
        hex = (0, converter_1.default)(17868022686844715136n).toHexString();
        (0, expect_1.expect)(hex).toBe('F7F7F7F700000080');
        hex = (0, converter_1.default)(17868022686844715136n).toHexString();
        (0, expect_1.expect)(hex).toBe('F7F7F7F700000080');
    });
    it('Should return hex, from float', async function () {
        let hex = (0, converter_1.default)(1.1).toHexString();
        (0, expect_1.expect)(hex).toBe('3F8CCCCD');
        hex = (0, converter_1.default)(-1.1).toHexString();
        (0, expect_1.expect)(hex).toBe('BF8CCCCD');
        hex = (0, converter_1.default)(-0.43431).toHexString();
        (0, expect_1.expect)(hex).toBe('BEDE5DE1');
    });
    it('Should return hex, from double precision float', async function () {
        let hex = (0, converter_1.default)(1.1).toHexString({ precision: 'DOUBLE' });
        (0, expect_1.expect)(hex).toBe('3FF199999999999A');
        hex = (0, converter_1.default)(-1.1).toHexString({ precision: 'DOUBLE' });
        (0, expect_1.expect)(hex).toBe('BFF199999999999A');
        hex = (0, converter_1.default)(-0.43431).toHexString({ precision: 'DOUBLE' });
        (0, expect_1.expect)(hex).toBe('BFDBCBBC2B94D940');
        hex = (0, converter_1.default)(-0.43431444344444443455).toHexString({ precision: 'DOUBLE' });
        (0, expect_1.expect)(hex).toBe('BFDBCBCECEB18EA1');
        hex = (0, converter_1.default)(3232434.43434556565666443).toHexString({ precision: 'DOUBLE' });
        (0, expect_1.expect)(hex).toBe('4148A9593798A2B0');
    });
    it('Should return bytes, from decimal', async function () {
        let bytes = (0, converter_1.default)(422).toBytes();
        (0, expect_1.expect)(bytes[0]).toBe('00000001'); //most significant byte!
        (0, expect_1.expect)(bytes[1]).toBe('10100110');
        (0, expect_1.expect)(bytes.length).toBe(2);
        bytes = (0, converter_1.default)(422).toBytes({ endianness: 'LITTLE' });
        (0, expect_1.expect)(bytes[0]).toBe('10100110');
        (0, expect_1.expect)(bytes[1]).toBe('00000001'); //most significant byte!
        bytes = (0, converter_1.default)(256).toBytes({ endianness: 'LITTLE' });
        (0, expect_1.expect)(bytes[0]).toBe('00000000');
        (0, expect_1.expect)(bytes[1]).toBe('00000001'); //most significant byte!
        bytes = (0, converter_1.default)(534545).toBytes();
        (0, expect_1.expect)(bytes[0]).toBe('00001000'); //most significant byte!
        (0, expect_1.expect)(bytes[1]).toBe('00101000');
        (0, expect_1.expect)(bytes[2]).toBe('00010001');
        bytes = (0, converter_1.default)(-534545).toBytes();
        (0, expect_1.expect)(bytes[0]).toBe('11111111'); //most significant byte!
        (0, expect_1.expect)(bytes[1]).toBe('11110111');
        (0, expect_1.expect)(bytes[2]).toBe('11010111');
        (0, expect_1.expect)(bytes[3]).toBe('11101111');
        bytes = (0, converter_1.default)(-143454544).toBytes(); //
        // [       "11110111",        "01110011",       "00001110",       "10110000"     ]
        (0, expect_1.expect)(bytes[0]).toBe('11110111'); //most significant byte!
        (0, expect_1.expect)(bytes[1]).toBe('01110011');
        (0, expect_1.expect)(bytes[2]).toBe('00001110');
        (0, expect_1.expect)(bytes[3]).toBe('10110000');
    });
    it('Should return bytes, from hex', async function () {
        let bytes = (0, converter_1.default)(0x1A6).toBytes();
        (0, expect_1.expect)(bytes[0]).toBe('00000001'); //most significant byte!
        (0, expect_1.expect)(bytes[1]).toBe('10100110');
        (0, expect_1.expect)(bytes.length).toBe(2);
        bytes = (0, converter_1.default)(0x1A6).toBytes({ endianness: 'LITTLE' });
        (0, expect_1.expect)(bytes[0]).toBe('10100110');
        (0, expect_1.expect)(bytes[1]).toBe('00000001'); //most significant byte!
        bytes = (0, converter_1.default)(0x100).toBytes({ endianness: 'LITTLE' });
        (0, expect_1.expect)(bytes[0]).toBe('00000000');
        (0, expect_1.expect)(bytes[1]).toBe('00000001'); //most significant byte!
        bytes = (0, converter_1.default)(0x82811).toBytes();
        (0, expect_1.expect)(bytes[0]).toBe('00001000'); //most significant byte!
        (0, expect_1.expect)(bytes[1]).toBe('00101000');
        (0, expect_1.expect)(bytes[2]).toBe('00010001');
        bytes = (0, converter_1.default)(-0x82811).toBytes();
        (0, expect_1.expect)(bytes[0]).toBe('11111111'); //most significant byte!
        (0, expect_1.expect)(bytes[1]).toBe('11110111');
        (0, expect_1.expect)(bytes[2]).toBe('11010111');
        (0, expect_1.expect)(bytes[3]).toBe('11101111');
        bytes = (0, converter_1.default)(-0x88CF150).toBytes(); //
        // [       "11110111",        "01110011",       "00001110",       "10110000"     ]
        (0, expect_1.expect)(bytes[0]).toBe('11110111'); //most significant byte!
        (0, expect_1.expect)(bytes[1]).toBe('01110011');
        (0, expect_1.expect)(bytes[2]).toBe('00001110');
        (0, expect_1.expect)(bytes[3]).toBe('10110000');
    });
    it('Should return bytes, from octal', async function () {
        let bytes = (0, converter_1.default)(0o646).toBytes();
        (0, expect_1.expect)(bytes[0]).toBe('00000001'); //most significant byte!
        (0, expect_1.expect)(bytes[1]).toBe('10100110');
        (0, expect_1.expect)(bytes.length).toBe(2);
        bytes = (0, converter_1.default)(0o646).toBytes({ endianness: 'LITTLE' });
        (0, expect_1.expect)(bytes[0]).toBe('10100110');
        (0, expect_1.expect)(bytes[1]).toBe('00000001'); //most significant byte!        
    });
    it('Should return byte decimals, from decimal', async function () {
        let bytes = (0, converter_1.default)(422).toDecimalBytes();
        (0, expect_1.expect)(bytes[0]).toBe(1); //most significant byte!
        (0, expect_1.expect)(bytes[1]).toBe(166); //
        (0, expect_1.expect)(bytes.length).toBe(2);
        bytes = (0, converter_1.default)(422).toDecimalBytes({ endianness: 'LITTLE' });
        (0, expect_1.expect)(bytes[0]).toBe(166);
        (0, expect_1.expect)(bytes[1]).toBe(1); //most significant byte!
        bytes = (0, converter_1.default)(256).toDecimalBytes({ endianness: 'LITTLE' });
        (0, expect_1.expect)(bytes[0]).toBe(0);
        (0, expect_1.expect)(bytes[1]).toBe(1); //most significant byte!
        bytes = (0, converter_1.default)(534545).toDecimalBytes();
        (0, expect_1.expect)(bytes[0]).toBe(8); //most significant byte!
        (0, expect_1.expect)(bytes[1]).toBe(40);
        (0, expect_1.expect)(bytes[2]).toBe(17);
        bytes = (0, converter_1.default)(-534545).toDecimalBytes();
        (0, expect_1.expect)(bytes[0]).toBe(255); //most significant byte!
        (0, expect_1.expect)(bytes[1]).toBe(247);
        (0, expect_1.expect)(bytes[2]).toBe(215);
        (0, expect_1.expect)(bytes[3]).toBe(239);
        bytes = (0, converter_1.default)(-143454544).toDecimalBytes();
        (0, expect_1.expect)(bytes[0]).toBe(247); //most significant byte!
        (0, expect_1.expect)(bytes[1]).toBe(115);
        (0, expect_1.expect)(bytes[2]).toBe(14);
        (0, expect_1.expect)(bytes[3]).toBe(176);
    });
    it('Should return byte decimals, from hex', async function () {
        let bytes = (0, converter_1.default)(0x1A6).toDecimalBytes();
        (0, expect_1.expect)(bytes[0]).toBe(0x1); //most significant byte!
        (0, expect_1.expect)(bytes[1]).toBe(0xA6); //
        (0, expect_1.expect)(bytes.length).toBe(2);
        bytes = (0, converter_1.default)(0x1A6).toDecimalBytes({ endianness: 'LITTLE' });
        (0, expect_1.expect)(bytes[0]).toBe(0xA6);
        (0, expect_1.expect)(bytes[1]).toBe(1); //most significant byte!
        bytes = (0, converter_1.default)(0x100).toDecimalBytes({ endianness: 'LITTLE' });
        (0, expect_1.expect)(bytes[0]).toBe(0);
        (0, expect_1.expect)(bytes[1]).toBe(1); //most significant byte!
        bytes = (0, converter_1.default)(0x82811).toDecimalBytes();
        (0, expect_1.expect)(bytes[0]).toBe(8); //most significant byte!
        (0, expect_1.expect)(bytes[1]).toBe(40);
        (0, expect_1.expect)(bytes[2]).toBe(17);
        bytes = (0, converter_1.default)(-0x82811).toDecimalBytes();
        (0, expect_1.expect)(bytes[0]).toBe(255); //most significant byte!
        (0, expect_1.expect)(bytes[1]).toBe(247);
        (0, expect_1.expect)(bytes[2]).toBe(215);
        (0, expect_1.expect)(bytes[3]).toBe(239);
        bytes = (0, converter_1.default)(-0x88CF150).toDecimalBytes();
        (0, expect_1.expect)(bytes[0]).toBe(247); //most significant byte!
        (0, expect_1.expect)(bytes[1]).toBe(115);
        (0, expect_1.expect)(bytes[2]).toBe(14);
        (0, expect_1.expect)(bytes[3]).toBe(176);
    });
    it('Should return byte decimals, from octal', async function () {
        let bytes = (0, converter_1.default)(0o646).toDecimalBytes();
        (0, expect_1.expect)(bytes[0]).toBe(1); //most significant byte!
        (0, expect_1.expect)(bytes[1]).toBe(166); //
        (0, expect_1.expect)(bytes.length).toBe(2);
    });
    it('Should return bytes, from float', async function () {
        let bytes = (0, converter_1.default)(1.1).toBytes();
        // ["00111111", "10001100", "11001100", "11001101"]
        (0, expect_1.expect)(bytes).toStrictEqual(["11001101", "11001100", "10001100", "00111111"]); //little enddian!
    });
    it('Should return bytes, from bigint', async function () {
        const bytes = (0, converter_1.default)(17868022686844715136n).toBytes({ endianness: 'LITTLE' });
        (0, expect_1.expect)(bytes).toStrictEqual(['11110111', '11110111', '11110111', '11110111', '00000000', '00000000', '00000000', '10000000'].reverse());
    });
    it('Should return binary, from bigint', async function () {
        const binary = (0, converter_1.default)(17868022686844715136n).toBinary();
        (0, expect_1.expect)(binary).toBe('1111011111110111111101111111011100000000000000000000000010000000');
    });
    it('Should return binary, from float', async function () {
        const binary = (0, converter_1.default)(-0.32323).toBinary();
        (0, expect_1.expect)(binary).toBe('10111110101001010111111001100111');
    });
    it('Should return binary, from hex', async function () {
        let binary = (0, converter_1.default)(0x296C167).toBinary();
        (0, expect_1.expect)(binary).toBe('10100101101100000101100111');
        binary = (0, converter_1.default)(0x3ede61d0).toBinary();
        (0, expect_1.expect)(binary).toBe('111110110111100110000111010000');
        binary = (0, converter_1.default)(0xbede61d0).toBinary();
        (0, expect_1.expect)(binary).toBe('10111110110111100110000111010000');
        binary = (0, converter_1.default)(0x440863d7).toBinary();
        (0, expect_1.expect)(binary).toBe('1000100000010000110001111010111');
        binary = (0, converter_1.default)(0xc40863d7).toBinary();
        (0, expect_1.expect)(binary).toBe('11000100000010000110001111010111');
    });
    it('Should return binary, from double precision float', async function () {
        let binary = (0, converter_1.default)(-0.32323).toBinary({ precision: 'DOUBLE' });
        (0, expect_1.expect)(binary).toBe('1011111111010100101011111100110011100001110001011000001001010110');
        binary = (0, converter_1.default)(555555.6565656565656565666).toBinary({ precision: 'DOUBLE' });
        (0, expect_1.expect)(binary).toBe('0100000100100000111101000100011101010000001010010101111110101101');
    });
    it('Should return float, from Number', async function () {
        let float = (0, converter_1.default)(0x296C167).toFloat();
        (0, expect_1.expect)(float.toString()).toContain('2.21515265');
        (0, expect_1.expect)(float.toString()).toContain('e-37');
        float = (0, converter_1.default)(0x3ede61d0).toFloat();
        (0, expect_1.expect)(float.toString()).toContain('0.43434000015');
        float = (0, converter_1.default)(0b00111110110111100110000111010000).toFloat();
        (0, expect_1.expect)(float.toString()).toContain('0.43434000015');
        float = (0, converter_1.default)(0o7667460720).toFloat();
        (0, expect_1.expect)(float.toString()).toContain('0.43434000015');
        float = (0, converter_1.default)(0xbede61d0).toFloat();
        (0, expect_1.expect)(float.toString()).toContain('-0.43434000015');
    });
    it('Should return double precision float, from Number', async function () {
        let float = (0, converter_1.default)(0x4001b8a1d57211ean).toFloat({ precision: 'DOUBLE' });
        (0, expect_1.expect)(float).toBe(2.2151524234234232);
        float = (0, converter_1.default)(0xffe1ccf385ebc8a0n).toFloat({ precision: 'DOUBLE' });
        (0, expect_1.expect)(float).toBe(-1e+308);
        float = (0, converter_1.default)(18438243695727462560n).toFloat({ precision: 'DOUBLE' });
        (0, expect_1.expect)(float).toBe(-1e+308);
        float = (0, converter_1.default)(18438243695727462560n).toFloat({ precision: 'DOUBLE' });
        (0, expect_1.expect)(float).toBe(-1e+308);
    });
    it('Should return decimal, from Number', async function () {
        let decimal = (0, converter_1.default)(0x296C167).toInteger();
        (0, expect_1.expect)(decimal).toBe(43434343);
        decimal = (0, converter_1.default)(0x3ede61d0).toInteger();
        (0, expect_1.expect)(decimal).toBe(1054761424);
        decimal = (0, converter_1.default)(0xbede61d0).toInteger();
        (0, expect_1.expect)(decimal).toBe(3202245072);
        decimal = (0, converter_1.default)(0xFFF4).toInteger();
        (0, expect_1.expect)(decimal).toBe(65524);
        decimal = (0, converter_1.default)(0o177764).toInteger();
        (0, expect_1.expect)(decimal).toBe(65524);
        decimal = (0, converter_1.default)(0b1111111111110100).toInteger();
        (0, expect_1.expect)(decimal).toBe(65524);
    });
    it('Should return decimal, from octal', async function () {
        let decimal = (0, converter_1.default)(0o245540547).toInteger();
        (0, expect_1.expect)(decimal).toBe(43434343);
        decimal = (0, converter_1.default)(0o7667460720).toInteger();
        (0, expect_1.expect)(decimal).toBe(1054761424);
        decimal = (0, converter_1.default)(9999999999999999n).toInteger();
        (0, expect_1.expect)(decimal).toBe(9999999999999999);
    });
    it('Should return decimal, from binary', async function () {
        let decimal = (0, converter_1.default)(0b100111100000101000100001000110111111).toInteger();
        (0, expect_1.expect)(decimal).toBe(42423423423);
    });
    it('Should return decimal, from other notations, signed convention', async function () {
        let decimal = (0, converter_1.default)(0xFFF4).toInteger({ isSigned: true });
        (0, expect_1.expect)(decimal).toBe(-12);
        decimal = (0, converter_1.default)(0x00000000BEDE61D0).toInteger({ isSigned: true });
        (0, expect_1.expect)(decimal).toBe(-1092722224);
        decimal = (0, converter_1.default)(0o27667460720).toInteger({ isSigned: true });
        (0, expect_1.expect)(decimal).toBe(-1092722224);
        decimal = (0, converter_1.default)(0b10111110110111100110000111010000).toInteger({ isSigned: true });
        (0, expect_1.expect)(decimal).toBe(-1092722224);
        decimal = (0, converter_1.default)(-0xFF).toInteger();
        (0, expect_1.expect)(decimal).toBe(-255);
    });
});
//# sourceMappingURL=node-number-converter.spec.js.map