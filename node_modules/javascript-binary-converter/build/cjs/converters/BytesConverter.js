"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const binary_1 = require("../utils/binary");
const hex_1 = require("../utils/hex");
const string_1 = require("../utils/string");
const typedArray_1 = require("../utils/typedArray");
const BaseBytesConverter_1 = require("./BaseBytesConverter");
class BytesConverter extends BaseBytesConverter_1.BaseBytesConverter {
    constructor(original) {
        super(original);
        this.original = original;
        this.original = this.original.map(byte => (0, string_1.padString)(byte)); //Make sure every byte has 8 bits, even if it's not mathematically needed
    }
    _getIntegers(isSigned = false) {
        return this.original.map(binary => (0, binary_1.binaryToInteger)(binary, isSigned));
    }
    toUint8Array() {
        return new Uint8Array(this._getIntegers());
    }
    toInt8Array() {
        return new Int8Array(this._getIntegers(true));
    }
    toUint16Array() {
        const integers = this._getIntegers(false);
        return new Uint16Array(new Uint8Array(integers).buffer);
    }
    toInt16Array() {
        const integers = this._getIntegers(true);
        return new Int16Array(new Int8Array(integers).buffer);
    }
    toUint32Array() {
        const integers = this._getIntegers(false);
        return new Uint32Array(new Uint8Array(integers).buffer);
    }
    toInt32Array() {
        const integers = this._getIntegers(true);
        return new Int32Array(new Int8Array(integers).buffer);
    }
    toBigInt64Array() {
        const integers = this._getIntegers(true);
        const bigintArray = new BigInt64Array(new Int8Array(integers).buffer);
        return bigintArray;
    }
    toBigUint64Array() {
        const integers = this._getIntegers(true); //
        const bigintArray = new BigUint64Array(new Uint8Array(integers).buffer);
        return bigintArray;
    }
    toFloat32Array() {
        const int32Array = this.toInt32Array();
        const float32Array = new Float32Array(int32Array.buffer);
        return float32Array;
    }
    /**
     * Defaults: isSigned = false, integerSize = 8
     */
    toIntegers({ isSigned = false, integerSize = 8 } = {}) {
        let typedArray;
        switch (integerSize) {
            case 8:
                return this.original.map(binary => (0, binary_1.binaryToInteger)(binary, isSigned));
            case 16:
                typedArray = isSigned ? this.toInt16Array() : this.toUint16Array();
                return (0, typedArray_1.typedArrayToIntegers)(typedArray);
            case 32:
                typedArray = isSigned ? this.toInt32Array() : this.toUint32Array();
                return (0, typedArray_1.typedArrayToIntegers)(typedArray);
            case 64:
                typedArray = isSigned ? this.toBigInt64Array() : this.toBigUint64Array();
                return (0, typedArray_1.typedArrayToIntegers)(typedArray);
            default:
                throw new Error('The integer size is invalid(8,16,32,64 are allowed)');
        }
    }
    toHexString({ isSigned = false } = {}) {
        return this.original.map((int) => (0, hex_1.integerToHexaDecimal)((0, binary_1.binaryToInteger)(int, isSigned)));
    }
}
exports.default = BytesConverter;
//# sourceMappingURL=BytesConverter.js.map