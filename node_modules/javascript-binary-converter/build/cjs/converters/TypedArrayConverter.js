"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const binary_1 = require("../utils/binary");
const crossPlatform_1 = require("../utils/crossPlatform");
const image_1 = require("../utils/image");
class TypedArrayConverter {
    constructor(original) {
        this.original = original;
    }
    toUint8Array() {
        return new Uint8Array(this.original.buffer);
    }
    toInt8Array() {
        return new Int8Array(this.original.buffer);
    }
    toInt16Array() {
        const int16 = new Int16Array(this.original.buffer);
        return int16;
    }
    toUint16Array() {
        const uint16 = new Uint16Array(this.original.buffer);
        return uint16;
    }
    toInt32Array() {
        return new Int32Array(this.original.buffer);
    }
    toUint32Array() {
        return new Uint32Array(this.original.buffer);
    }
    toBigUint64Array() {
        return new BigUint64Array(this.original.buffer);
    }
    toBigInt64Array() {
        return new BigInt64Array(this.original.buffer);
    }
    toFloat32() {
        return new Float32Array(this.original.buffer);
    }
    toText() {
        const decoder = new TextDecoder();
        return decoder.decode(this.original);
    }
    async toBlob(config) {
        const BlobClass = await (0, crossPlatform_1.getBlobClass)();
        return new BlobClass([this.original], config);
    }
    async toImage(config) {
        return (0, image_1.binaryToImage)(await this.toBlob(), config && config);
    }
    toBytes() {
        const bytes = this.original instanceof Uint8Array ? (0, binary_1.typedArrayToBytes)(this.original) : (0, binary_1.typedArrayToBytes)(new Uint8Array(this.original));
        return bytes;
    }
    toDecimalBytes() {
        const bytes = this.toBytes();
        return (0, binary_1.bytesToIntegers)(bytes);
    }
}
exports.default = TypedArrayConverter;
//# sourceMappingURL=TypedArrayConverter.js.map